---
title: Print version information in Haskell programs
author: Stefan Klinger <https://stefan-klinger.de/>
---

The task
========

The compiled binary must provide the following information:

  * The version number it was assigned in the cabal file.

  * The git hash that represents the latest commit before compilation,
    including “dirtiness”.  Maybe add the commit's date in the future.

  * The time the binary was compiled.

Collect the interface to this information in a common module
[`Compiletime.Info`][1].


The struggle
============

Compilation time
----------------

The easiest one is compilation time.  Using Template Haskell, the
current time can easily be [calculated][2] at compile time, and then
[spliced][3] into the program:


The version number from the cabal file
--------------------------------------

This can be accessed by the magic (and largely undocumented) API
provided in an autogenerated module named [`Paths_…`][4]

Building my application around RIO, I was hoping to get along without
depending on `base` at all.  Well, o.k., I'd accept `Setup.hs` to
depend on `base`, assuming this is code running in a pre-compilation
situation and has little to do with the inner workings of my program.

But the `Paths_…` module thwarts that plan

    module Paths_versionInfo ( … ) where

    import qualified Control.Exception as Exception
    import Data.Version (Version(..))
    import System.Environment (getEnv)
    import Prelude

and that is code compiled into the resulting binary.  I can live with
it, but it's not extra cool, is it?


The git hash, oh my
-------------------

Wait, there's a package for it: [gitrev][5] — but that just [don't cut
the mustard][6].

Obviously, if the git repository is not available at compile time,
then there's a problem.  This is a legit scenario though, I might want
to publish the source without revealing my history of fallacies and
transgressions.

Basicaly, asking for a git hash introduces a dependency on the SCM,
which is not nice to have, but a burden.  And consequently, Cabal
makes this problem obvious when *installing* a program using
[gitrev][6]: The build happens in a temporary directory (not
containing the `.git` subdirectory that was available during
*building*), and thus reaching out to `git` fails.

But still, I think it is legit to ask what commit a binary (or source
distribution) was created from.

I've resorted to creating a `githash` file to convey the hash into the
source distribution file used for `cabal install` and also for
shipping.

Using this file is easy, see [Compiletime.Templates][7], and
[Compiletime.Info][8].  But its creation is ugly, [`Setup.hs`][9]
always tries to write a new `githash` file, or fails silently.


Conclusion
==========

Conceptually, I see two phases at work here.  The first is the step
from the cloned git repository to the source distribution directory,
and the second is the actual compilation (which could be further split
into collecting compile time information, splicing that into the code,
and compiling)

I do not see Cabal's [user interface][11] providing a clear line
between these two phases.  It is probably there, somewhere, but I
can't put my finger on it any better.  I've tried to define
[hooks][10], got no better result but more convolution.


The pain
--------

  * Now there's another file lying around, sometimes.  What's the
    right place and name to put it?  How does this scale to managing
    more information (like git commit date)?

  * The package is kinda broken:

        $ cabal check
        Warning: These warnings may cause trouble when distributing the package:
        Warning: In 'extra-source-files': the pattern 'githash' does not match any
        files.

    but `cabal sdist` will fix this.

  * I had to write my own [`Setup.hs`](Setup.hs), with a rather
    unsatisfying heuristic to always overwrite `./githash` if `git`
    was successful, and to hope it contained the right value
    otherwise.

  * After cloning from git, it is now mandatory to `cabal build`
    before `cabal install`, otherwise

        cabal: filepath wildcard 'githash' does not match any files.

    But installation from a source distribution tarball is fine,
    because it now contains `githash`.

  * This approach bears some complexity.

  * I don't like `Paths_…` pulling in `base`.


[1]: src/Compiletime/Info.hs
[2]: src/Compiletime/Templates.hs#L7-L11
[3]: src/Compiletime/Info.hs#L12-L13
[4]: src/Compiletime/Info.hs#L15-L16
[5]: https://www.stackage.org/haddock/lts-18.2/gitrev-1.3.1/Development-GitRev.html
[6]: https://github.com/acfoltzer/gitrev/issues/23
[7]: src/Compiletime/Templates.hs#L13-L14
[8]: src/Compiletime/Info.hs#L18-L19
[9]: Setup.hs#L12-L29
[10]: https://hackage.haskell.org/package/Cabal-3.4.0.0/docs/Distribution-Simple.html
[11]: https://cabal.readthedocs.io/en/3.4/index.html
